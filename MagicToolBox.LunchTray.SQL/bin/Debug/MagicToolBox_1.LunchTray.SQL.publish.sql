/*
Deployment script for BreadBoard

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "BreadBoard"
:setvar DefaultFilePrefix "BreadBoard"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE,
                DISABLE_BROKER 
            WITH ROLLBACK IMMEDIATE;
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367)) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Dropping [dbo].[DF_SessionEventLog_Billable]...';


GO
ALTER TABLE [dbo].[SessionEventLog] DROP CONSTRAINT [DF_SessionEventLog_Billable];


GO
PRINT N'Dropping [dbo].[DF_SessionEventLog_Start]...';


GO
ALTER TABLE [dbo].[SessionEventLog] DROP CONSTRAINT [DF_SessionEventLog_Start];


GO
PRINT N'Dropping [dbo].[FK_SessionEventLog_EventTypeID]...';


GO
ALTER TABLE [dbo].[SessionEventLog] DROP CONSTRAINT [FK_SessionEventLog_EventTypeID];


GO
PRINT N'Creating [rpt]...';


GO
CREATE SCHEMA [rpt]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [views]...';


GO
CREATE SCHEMA [views]
    AUTHORIZATION [dbo];


GO
PRINT N'Starting rebuilding table [dbo].[SessionEventLog]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_SessionEventLog] (
    [ID]          INT            IDENTITY (1, 1) NOT NULL,
    [EventTypeID] INT            NOT NULL,
    [Billable]    BIT            CONSTRAINT [DF_SessionEventLog_Billable] DEFAULT (0) NOT NULL,
    [Start]       DATETIME       CONSTRAINT [DF_SessionEventLog_Start] DEFAULT (GetDate()) NOT NULL,
    [Ended]       DATETIME       NULL,
    [Message]     NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_SessionEventLog_ID1] PRIMARY KEY CLUSTERED ([ID] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[SessionEventLog])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_SessionEventLog] ON;
        INSERT INTO [dbo].[tmp_ms_xx_SessionEventLog] ([ID], [EventTypeID], [Billable], [Start], [Ended], [Message])
        SELECT   [ID],
                 [EventTypeID],
                 [Billable],
                 [Start],
                 [Ended],
                 CAST ([Message] AS NVARCHAR (255))
        FROM     [dbo].[SessionEventLog]
        ORDER BY [ID] ASC;
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_SessionEventLog] OFF;
    END

DROP TABLE [dbo].[SessionEventLog];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_SessionEventLog]', N'SessionEventLog';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PK_SessionEventLog_ID1]', N'PK_SessionEventLog_ID', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating [dbo].[FK_SessionEventLog_EventTypeID]...';


GO
ALTER TABLE [dbo].[SessionEventLog] WITH NOCHECK
    ADD CONSTRAINT [FK_SessionEventLog_EventTypeID] FOREIGN KEY ([EventTypeID]) REFERENCES [dbo].[SessionEventTypes] ([ID]);


GO
PRINT N'Creating [views].[SessionEventLog_WorkDays]...';


GO
/*
================================================================================
Author: John Williams
Create Date: 09/14/2018
Description: This view summarizes the session events to 1 row per date worked
             When the day started, ended, and the difference between them "DayLength"
--------------------------------------------------------------------------------

--- Change Log -----------------------------------------------------------------
Date          Author    Description
-----------   -------   ---------------------------------------------------------
09/14/2018    JHW       • Added this view to make the comparison between billable & break hours
12/28/2018    JHW       • Added Break Time Aggregate Metrics
01/02/2019    JHW       • Added case statement to use the current time as DayEnded and to calculate DayLength if the WorkDate is the current date
================================================================================ */
Create View views.SessionEventLog_WorkDays
As
--------------------------------------------------------------------------------
Select WorkWeek = DatePart(Week, Max(e.Ended))
       -------------------------------------------------------------------------
      ,WorkDate = Convert(Date, e.Start)
       -------------------------------------------------------------------------
      ,DayStart = Min(e.Start)
      ,DayEnded = Case
                    When Convert(Date, Max(e.Ended)) = Convert(Date, GetDate())
                    Then GetDate()
                    Else Max(e.Ended)
                  End
       -------------------------------------------------------------------------
      ,DayLength = Case
                    --- If it's today then just return the current time as the day has yet to end
                    When Convert(Date, Max(e.Ended)) = Convert(Date, GetDate())
                    Then Format(GetDate() - Min(e.Start), 'HH:mm')
                    --- Get the last timestamp from the day of the record
                    Else Format(Max(e.Ended) - Min(e.Start), 'HH:mm')
                  End
       -------------------------------------------------------------------------
      ,[Breaks += 0:10] = FormatMessage('%s Breaks @ %s total each averaging %s'
                                        ,Format(Count(Distinct bo10.ID), '#,##0')
                                        ,Format(Floor(Sum(Distinct IsNull(DateDiff(ss, bo10.Start, bo10.Ended), 0)) / 3600.00), '0') -- Hours (Add all seconds up / 3600)
                                        +Format(Sum(Distinct IsNull(DateDiff(ss, bo10.Start, bo10.Ended), 0)) % 3600.00 / 60, ':00')    -- Minutes (Add all seconds up % 3600 / 60)
                                        ,Format(Floor(Avg(IsNull(DateDiff(ss, bo10.Start, bo10.Ended), 0)) / 3600.00), '0') -- Hours (Add all seconds up / 3600)
                                        +Format(Avg(IsNull(DateDiff(ss, bo10.Start, bo10.Ended), 0)) % 3600.00 / 60, ':00')    -- Minutes (Add all seconds up % 3600 / 60)
                          )
       -------------------------------------------------------------------------
      ,[Breaks <- 0:10] = FormatMessage('%s Breaks @ %s total each averaging %s'
                                        ,Format(Count(Distinct bu10.ID), '#,##0')
                                        ,Format(Floor(Sum(Distinct IsNull(DateDiff(ss, bu10.Start, bu10.Ended), 0)) / 3600.00), '0') -- Hours (Add all seconds up / 3600)
                                        +Format(Sum(Distinct IsNull(DateDiff(ss, bu10.Start, bu10.Ended), 0)) % 3600.00 / 60, ':00')    -- Minutes (Add all seconds up % 3600 / 60)
                                        ,Format(Floor(Avg(IsNull(DateDiff(ss, bu10.Start, bu10.Ended), 0)) / 3600.00), '0') -- Hours (Add all seconds up / 3600)
                                        +Format(Avg(IsNull(DateDiff(ss, bu10.Start, bu10.Ended), 0)) % 3600.00 / 60, ':00')    -- Minutes (Add all seconds up % 3600 / 60)
                          )
--------------------------------------------------------------------------------
  From dbo.SessionEventLog e
--------------------------------------------------------------------------------
--- Join to aggregate break times 10 or minutes in length ----------------------
--------------------------------------------------------------------------------
  Left Join dbo.SessionEventLog bo10
    On bo10.Billable = 0 -- Anything not Billable is considered a break
   And Convert(Date, bo10.Start) = Convert(Date, e.Start)  -- Only match records of the same day as the from records date
   And Convert(Date, bo10.Ended) = Convert(Date, e.Ended)  -- Only match records of the same day as the from records date
   -- 2 minutes here, 4 minutes there aren't really "breaks"
   And Not ( DateDiff(mi, bo10.Start, bo10.Ended) < 10 ) -- Only count breaks over 10 minutes 
--------------------------------------------------------------------------------
--- Join to aggregate break times below 10 minutes in length -------------------
--------------------------------------------------------------------------------
  Left Join dbo.SessionEventLog bu10
    On bu10.Billable = 0 -- Anything not Billable is considered a break
   And Convert(Date, bu10.Start) = Convert(Date, e.Start)  -- Only match records of the same day as the from records date
   And Convert(Date, bu10.Ended) = Convert(Date, e.Ended)  -- Only match records of the same day as the from records date
   -- 2 minutes here, 4 minutes there aren't really "breaks"
   And ( DateDiff(mi, bu10.Start, bu10.Ended) < 10 ) -- Only count breaks over 10 minutes 
--------------------------------------------------------------------------------
 Where DateDiff(Day, e.Start, e.Ended) = 0  -- Excludes overnight periods from counting towards breaktime
--------------------------------------------------------------------------------
   And e.Billable = 1
--------------------------------------------------------------------------------
 Group By
       Convert(Date, e.Start)
--------------------------------------------------------------------------------
GO
PRINT N'Altering [tool].[FormatText]...';


GO
/*
================================================================================
Author: John Williams
Create Date: 01/01/2012
Description: This function will format/parse text and replace c# escape characters with proper sql characters
             i.e. \r\n is carriage return+line feed in C# but is Char(13)+Char(10) in T-SQL
--------------------------------------------------------------------------------

--- Change Log -----------------------------------------------------------------
Date          Author    Description
-----------   -------   ---------------------------------------------------------
01/01/2012    JHW       • Created This Proc
================================================================================ */
ALTER Function tool.FormatText (
  @Format nVarChar(3000)
)
--------------------------------------------------------------------------------
Returns nVarChar(4000)
As
Begin
--------------------------------------------------------------------------------
Declare @Return VarChar(4000) = @Format
--------------------------------------------------------------------------------
--- Loop Iteration Variables ---------------------------------------------------
Declare @ix Int, @Code Int, @Char Char(4)
--------------------------------------------------------------------------------
-- Parse out any C# style escape characters ------------------------------------
If PatIndex('%\[TtNnRrQq%]', @Return) > 0
Begin
  Set @Return = Replace(@Return, '\T', Char(9))  -- Tab
  Set @Return = Replace(@Return, '\N', Char(10)) -- Line Feed
  Set @Return = Replace(@Return, '\R', Char(13)) -- Carriage Return
  -- \Q is custom for this routine only. It's not a valid C# escape character 
  Set @Return = Replace(@Return, '\Q', Char(39)) -- Single quote
End
-------------------------------------------------------------------------------
-- Initialize Loop 
-- Look for any instances ascii character codes defined explicitly using \000 format
-------------------------------------------------------------------------------
Select @ix = PatIndex('%\[0-9][0-9][0-9] %', @Return)
-------------------------------------------------------------------------------
 While @ix > 0
 ------------------------------------------------------------------------------
 Begin
    ---------------------------------------------------------------------------
    Select @Char = SubString(@Return, @ix, 4)
    Select @Code = Right(@Char, 3)
    -- Do the replacement(s) for any valid Ascii Code 
    Select @Return = Replace(@Return, @Char, Char(@Code))
     Where @Code <= 255
    -- Iterate Loop Next
    Select @ix = PatIndex('%\[0-9][0-9][0-9] %', @Return)
    ---------------------------------------------------------------------------
 End
-------------------------------------------------------------------------------
Return @Return
-------------------------------------------------------------------------------
End
GO
PRINT N'Altering [tool].[FormatString]...';


GO
/*
================================================================================
     Author: John Williams
Create Date: 01/01/2012
Description: This function will format/parse text like C# string.Format()             
    Example: Select FormatString = tool.FormatString('Arg0: {0}\NArg1: {1}\NArg2: {2}', 'Zero', 'One', 'Two')
--------------------------------------------------------------------------------

--- Change Log -----------------------------------------------------------------
Date          Author    Description
-----------   -------   ---------------------------------------------------------
01/01/2012    JHW       • Created This Function
================================================================================ */
ALTER Function tool.FormatString (
  @Format VarChar(Max)
 ,@Arg0 VarChar(Max)
 ,@Arg1 VarChar(Max) = Null
 ,@Arg2 VarChar(MAX) = NULL
)
--------------------------------------------------------------------------------
Returns VarChar(Max)
As
Begin
---------------------------------------------------------------------------------
  Declare @Return VarChar(Max)
  -------------------------------------------------------------------------------
  --- Parse out any .Net style string format variables
  Set @Return = @Format
  Set @Return = Replace(@Return, '{0}', IsNull(@Arg0, ''))
  Set @Return = Replace(@Return, '{1}', IsNull(@Arg1, ''))
  Set @Return = Replace(@Return, '{2}', IsNull(@Arg2, ''))
  -- Return The Results!!
  Set @Return = tool.FormatText(@Return)
  Return @Return
  -------------------------------------------------------------------------------
End
GO
PRINT N'Altering [tool].[FormatString1]...';


GO
/*
================================================================================
     Author: John Williams
Create Date: 01/01/2012
Description: This function will format/parse text like C# string.Format()             
    Example: Select FormatString = tool.FormatString1('Arg0: {0}, 'Zero')
--------------------------------------------------------------------------------

--- Change Log -----------------------------------------------------------------
Date          Author    Description
-----------   -------   ---------------------------------------------------------
01/01/2012    JHW       • Created This Function
================================================================================ */
ALTER Function tool.FormatString1 (
  @Format VarChar(Max)
 ,@Arg0 VarChar(Max)
)
--------------------------------------------------------------------------------
Returns VarChar(Max) As
---------------------------------------------------------------------------------
Begin
---------------------------------------------------------------------------------
   -- Make a call to the normal 3 argument tool.FormatString
   Return tool.FormatString(@Format, @Arg0, Default, Default)
---------------------------------------------------------------------------------
End
---------------------------------------------------------------------------------
GO
PRINT N'Altering [dbo].[SessionEventLog_Insert]...';


GO
/*
================================================================================
Author: John Williams
Create Date: 08/28/2018
Description: Inserts A Record To dbo.SessionEventLog and returns Scope_Identity()
--------------------------------------------------------------------------------

--- Change Log -----------------------------------------------------------------
Date          Author    Description
-----------   -------   ---------------------------------------------------------
08/28/2018    JHW       • Created This Stored Procedure
09/07/2018    JHW       • Added Billable column to capture default from types
                          but allow override to mark a break as billable (Meeting, etc) 
================================================================================ */
ALTER Proc dbo.SessionEventLog_Insert
  @EventTypeID Int
 ,@Start DateTime
 ,@Ended DateTime = Null
 ,@Message Text = Null
 ,@NewID Int = Null Out
As
--------------------------------------------------------------------------------
Insert dbo.SessionEventLog(EventTypeID, Billable, Start, Ended, Message)
--------------------------------------------------------------------------------
Select EventTypeID = t.ID
      ,Billable = t.Billable
      ,Start = @Start
      ,Ended = @Ended
      ,Message = @Message
--------------------------------------------------------------------------------
  From dbo.SessionEventTypes t
--------------------------------------------------------------------------------
 Where t.ID = @EventTypeID
--------------------------------------------------------------------------------
Select @NewID = Scope_Identity()
Return @NewID
--------------------------------------------------------------------------------
GO
PRINT N'Creating [rpt].[SessionEventLog_SummaryDetail]...';


GO
/*
================================================================================
     Author: John Williams
Create Date: 09/12/2018
Description: This proc will give a summary of the week number provided in @Week
    Example: Declare @ThisWeekNo Int = DatePart(wk, DateAdd(wk,  0, GetDate())) -- Get THIS Weeks Data (  0 )
                    ,@LastWeekNo Int = DatePart(wk, DateAdd(wk, -1, GetDate())) -- Get LAST Weeks Data ( -1 )
             Exec rpt.SessionEventLog_SummaryDetail @ThisWeekNo, 2018, 10
             Exec rpt.SessionEventLog_SummaryDetail @LastWeekNo, 2018, 10
--------------------------------------------------------------------------------

--- Change Log -----------------------------------------------------------------
Date          Author    Description
-----------   -------   ---------------------------------------------------------
09/12/2018     JHW      • Added this stored procedure to show an accounting of time
09/14/2018     JHW      • Changed EventSummary query to match the excel timesheet format
                        • Converted columns limiting their width to display best in text output modefrom
                        • Updated EventSummary to use a new view that was added to simplify the EventSummary query
================================================================================ */
Create Proc rpt.SessionEventLog_SummaryDetail
  @Week Int
 ,@Year Int = 2018
 ,@BreakMin Int = 10 -- Set a threshold for minimum break length 
As
--------------------------------------------------------------------------------
Set NoCount On
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
EventSummary: ------------------------------------------------------------------
--------------------------------------------------------------------------------
Select WeekNum = Convert(Char(8), @Week)
      ,DayName = Convert(Char(8), Format(w.WorkDate, 'ddd'))
      ,WorkDate = Convert(Char(12), w.WorkDate)
       -------------------------------------------------------------------------
      ,DayStart = Format(w.DayStart, 'HH:mm')
      ,DayEnded = Format(w.DayEnded, 'HH:mm')
      ,w.DayLength
       -------------------------------------------------------------------------
      ,BreaksTotal = Format(Floor(Sum(IsNull(DateDiff(ss, nb.Start, nb.Ended), 0)) / 3600.00), '00:') -- Hours (Add all seconds up / 3600)
                   + Format(Sum(IsNull(DateDiff(ss, nb.Start, nb.Ended), 0)) % 3600.00 / 60, '00')       -- Minutes (Add all seconds up % 3600 / 60)
      ,BilledTotal = Format(Convert(DateTime, w.DayLength)
                   - Convert(DateTime, Format(Floor(Sum(IsNull(DateDiff(ss, nb.Start, nb.Ended), 0)) / 3600.00), '00:') 
                                     + Format(Sum(IsNull(DateDiff(ss, nb.Start, nb.Ended), 0)) % 3600.00 / 60, '00')
                     ), 'HH:mm')
--------------------------------------------------------------------------------
  From views.SessionEventLog_WorkDays w
--------------------------------------------------------------------------------
--- Join to find break time totals ---------------------------------------------
--------------------------------------------------------------------------------
  Left Join dbo.SessionEventLog nb
    On Convert(Date, nb.Start) = w.WorkDate
   And Convert(Date, nb.Ended) = w.WorkDate
   And Not ( DateDiff(mi, nb.Start, nb.Ended) < @BreakMin )-- Only Count Breaks > 10 Minutes
   And nb.Billable = 0 -- Anything not Billable is considered a break
--------------------------------------------------------------------------------
 Where Year(w.WorkDate) = @Year          -- The year we want data from
   And DatePart(wk, w.WorkDate) = @Week  -- The Week we want data for
--------------------------------------------------------------------------------                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              --------------------------------------------------------------------------------
 Group By
       w.WorkDate
      ,w.DayStart
      ,w.DayEnded
      ,w.DayLength
--------------------------------------------------------------------------------
 Order By
       w.WorkDate
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
EventDetails: ------------------------------------------------------------------
--------------------------------------------------------------------------------
Select EventID = e.ID
       -------------------------------------------------------------------------
      ,WorkType = Case(e.Billable)
                    ------------------------------------------------------------
                    When 1 Then Convert(nChar(10), 'WorkTime')
                    When 0 Then Convert(nChar(10), 'BreakTime')
                    ------------------------------------------------------------
                  End
       -------------------------------------------------------------------------
      ,ValidBreak = Case
                      ----------------------------------------------------------
                      When e.Billable = 0
                       And Not ( DateDiff(mi, e.Start, e.Ended) < @BreakMin )
                      Then 'YES'
                      ----------------------------------------------------------
                      When e.Billable = 1
                      Then ''
                      ----------------------------------------------------------
                      Else 'NO'
                      ----------------------------------------------------------
                   End
       -------------------------------------------------------------------------
      ,EventStart = Convert(Char(18), Format(e.Start, 'MM/dd/yyyy HH:mm'))
      ,EventEnded = Convert(Char(18), Format(e.Ended, 'MM/dd/yyyy HH:mm'))
      ,EventLength = Convert(Char(3), Format(Format(e.Ended - e.Start, 'dd') - 1, '00:'))
                   + Convert(Char(10), Format(e.Ended - e.Start, 'HH:mm:ss'))
      ,EventMessage = Convert(Char(80), e.Message)
--------------------------------------------------------------------------------
  From dbo.SessionEventLog e
--------------------------------------------------------------------------------
  Left Join dbo.SessionEventTypes t
    On t.ID = e.EventTypeID
--------------------------------------------------------------------------------
 Where DatePart(wk, e.Start) = @Week  -- Get data for the selected week
   --And ( e.Billable = 0 And Not ( DateDiff(mi, e.Start, e.Ended) < @BreakMin )-- Only Count Breaks > 10 Minutes
   --   Or e.Billable = 1
   --)
--------------------------------------------------------------------------------
 Order By
       EventID
--------------------------------------------------------------------------------
GO
/*
Post-Deployment Script Template                     
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.      
 Use SQLCMD syntax to include a file in the post-deployment script.
 Example:      :r .\myfile.sql                        
 Use SQLCMD syntax to reference a variable in the post-deployment script.
 Example:      :setvar TableName MyTable                     
               SELECT * FROM [$(TableName)]
--------------------------------------------------------------------------------------
*/
--- Turn ON so that ID = Microsoft.Win32.SessionSwitchReason Enum --------------
Set Identity_Insert dbo.SessionEventTypes On
--------------------------------------------------------------------------------

--- Insert The Event Types -----------------------------------------------------
Insert dbo.SessionEventTypes(ID, Name, Billable, Description)
--------------------------------------------------------------------------------
Values
(5, 'SessionLogOn' , 1, 'Microsoft.Win32.SessionSwitchReason; The user session state changes to SessionLogOn when the workstation logs on'   ),
(6, 'SessionLogOff', 1, 'Microsoft.Win32.SessionSwitchReason; The user session state changes to SessionLogOff when the workstation logs off' ),
(7, 'SessionLock'  , 1, 'Microsoft.Win32.SessionSwitchReason; The user session state changes to SessionLock when the workstation is locked'  ),
(8, 'SessionUnlock', 0, 'Microsoft.Win32.SessionSwitchReason; The user session state changes to SessionLock when the workstation is locked'  )
--------------------------------------------------------------------------------

--- Turn OFF Identity Insert ---------------------------------------------------
Set Identity_Insert dbo.SessionEventTypes Off
--------------------------------------------------------------------------------
GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[SessionEventLog] WITH CHECK CHECK CONSTRAINT [FK_SessionEventLog_EventTypeID];


GO
PRINT N'Update complete.';


GO
